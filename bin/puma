#!/usr/bin/env ruby
#
# Copyright (c) 2011 Evan Phoenix
# Copyright (c) 2005 Zed A. Shaw
#

require 'yaml'
require 'etc'

require 'puma'

Puma::Gems.require 'puma/gem_plugin'

# require 'ruby-debug'
# Debugger.start

module Puma
  class Start < GemPlugin::Plugin "/commands"
    include Puma::Command::Base

    def configure
      options [
        ['-p', '--port PORT', "Which port to bind to", :@port, 3000],
        ['-a', '--address ADDR', "Address to bind to", :@address, "0.0.0.0"],
        ['-l', '--log FILE', "Where to write log messages", :@log_file, "log/puma.log"],
        ['-P', '--pid FILE', "Where to write the PID", :@pid_file, "log/puma.pid"],
        ['-n', '--concurrency INT', "Number of concurrent threads to use",
                                    :@concurrency, 16],
        ['-c', '--chdir PATH', "Change to dir before starting (will be expanded)", :@cwd, Dir.pwd],
        ['-C', '--config PATH', "Use a config file", :@config_file, nil],
        ['-S', '--script PATH', "Load the given file as an extra config script", :@config_script, nil],
        ['-G', '--generate PATH', "Generate a config file for use with -C", :@generate, nil],
        ['-r', '--rackup PATH', 'Load a specific rackup file', :@rackup_file, "config.ru"],
        ['', '--user USER', "User to run as", :@user, nil],
        ['', '--group GROUP', "Group to run as", :@group, nil]
      ]
    end

    def validate
      if @config_file
        valid_exists?(@config_file, "Config file not there: #@config_file")
        return false unless @valid
        @config_file = File.expand_path(@config_file)
        load_config
        return false unless @valid
      end

      @cwd = File.expand_path(@cwd)
      valid_dir? @cwd, "Invalid path to change to during daemon mode: #@cwd"

      # Change there to start, then we'll have to come back after daemonize
      Dir.chdir(@cwd)

      valid_dir? File.dirname(@log_file), "Path to log file not valid: #@log_file"
      valid_dir? File.dirname(@pid_file), "Path to pid file not valid: #@pid_file"
      valid_exists? @mime_map, "MIME mapping file does not exist: #@mime_map" if @mime_map
      valid_exists? @config_file, "Config file not there: #@config_file" if @config_file
      valid_dir? File.dirname(@generate), "Problem accessing directory to #@generate" if @generate
      valid_user? @user if @user
      valid_group? @group if @group

      @rackup = ARGV.shift || "config.ru"

      valid? File.exists?(@rackup), "Unable to find rackup file"

      return @valid
    end

    def run
      if @generate
        @generate = File.expand_path(@generate)
        @stderr.puts "** Writing config to \"#@generate\"."
        open(@generate, "w") {|f| f.write(settings.to_yaml) }
        @stderr.puts "** Finished.  Run \"puma_rails start -C #@generate\" to use the config file."
        exit 0
      end

      rackup = @rackup

      config = Puma::Configurator.new(settings) do |c|
        c.log "Starting Puma listening at #{c.defaults[:host]}:#{c.defaults[:port]}"

        c.listener do |l|
          l.load_rackup rackup

          l.load_plugins

          if c.defaults[:config_script]
            c.log "Loading #{c.defaults[:config_script]} external config script"
            c.run_config(c.defaults[:config_script])
          end
        end
      end

      config.run
      config.log "Puma #{Puma::Const::PUMA_VERSION} available at #{@address}:#{@port}"
      config.log "Use CTRL-C to stop." 

      config.join
    end

    def load_config
      settings = {}
      begin
        settings = YAML.load_file(@config_file)
      ensure
        @stderr.puts "** Loading settings from #{@config_file} (they override command line)."
      end

      settings[:includes] ||= ["puma"]

      # Config file settings will override command line settings
      settings.each do |key, value|
        key = key.to_s
        if config_keys.include?(key)
          key = 'address' if key == 'host'
          self.instance_variable_set("@#{key}", value)
        else
          failure "Unknown configuration setting: #{key}"  
          @valid = false
        end
      end
    end

    def config_keys
      @config_keys ||=
        %w(address host port cwd log_file pid_file config_script concurrency user group)
    end

    def settings
      config_keys.inject({}) do |hash, key|
        value = self.instance_variable_get("@#{key}")
        key = 'host' if key == 'address'
        hash[key.to_sym] ||= value
        hash
      end
    end
  end

  def Puma.send_signal(signal, pid_file)
    pid = File.read(pid_file).to_i 
    print "Sending #{signal} to Puma at PID #{pid}..."
    begin
      Process.kill(signal, pid)
    rescue Errno::ESRCH
      puts "Process does not exist.  Not running."
    end

    puts "Done."
  end

  class Stop < GemPlugin::Plugin "/commands"
    include Puma::Command::Base

    def configure 
      options [ 
        ['-c', '--chdir PATH', "Change to dir before starting (will be expanded).", :@cwd, "."],
        ['-f', '--force', "Force the shutdown (kill -9).", :@force, false],
        ['-w', '--wait SECONDS', "Wait SECONDS before forcing shutdown", :@wait, "0"], 
        ['-P', '--pid FILE', "Where the PID file is located.", :@pid_file, "log/puma.pid"]
      ]
    end

    def validate
      @cwd = File.expand_path(@cwd)
      valid_dir? @cwd, "Invalid path to change to during daemon mode: #@cwd"

      Dir.chdir @cwd

      valid_exists? @pid_file, "PID file #@pid_file does not exist.  Not running?"
      return @valid
    end

    def run
      if @force
        @wait.to_i.times do |waiting|
          exit(0) if not File.exist? @pid_file
          sleep 1
        end

        Puma.send_signal("KILL", @pid_file) if File.exist? @pid_file
      else
        Puma.send_signal("TERM", @pid_file)
      end
    end
  end


  class Restart < GemPlugin::Plugin "/commands"
    include Puma::Command::Base

    def configure 
      options [ 
        ['-c', '--chdir PATH', "Change to dir before starting (will be expanded)", :@cwd, '.'],
        ['-s', '--soft', "Do a soft restart rather than a process exit restart", :@soft, false],
        ['-P', '--pid FILE', "Where the PID file is located", :@pid_file, "log/puma.pid"]
      ]
    end

    def validate
      @cwd = File.expand_path(@cwd)
      valid_dir? @cwd, "Invalid path to change to during daemon mode: #@cwd"

      Dir.chdir @cwd

      valid_exists? @pid_file, "PID file #@pid_file does not exist.  Not running?"
      return @valid
    end

    def run
      if @soft
        Puma.send_signal("HUP", @pid_file)
      else
        Puma.send_signal("USR2", @pid_file)
      end
    end
  end
end


GemPlugin::Manager.instance.load "puma" => GemPlugin::INCLUDE

exit 1 unless Puma::Command::Registry.instance.run(ARGV)
